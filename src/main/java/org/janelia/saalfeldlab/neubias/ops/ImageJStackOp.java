package org.janelia.saalfeldlab.neubias.ops;

import java.util.Arrays;
import java.util.function.Consumer;

import org.janelia.saalfeldlab.neubias.util.Util;

import ij.ImagePlus;
import ij.process.FloatProcessor;
import net.imglib2.RandomAccessible;
import net.imglib2.RandomAccessibleInterval;
import net.imglib2.converter.Converters;
import net.imglib2.img.imageplus.ImagePlusImgs;
import net.imglib2.type.NativeType;
import net.imglib2.type.numeric.RealType;
import net.imglib2.type.numeric.real.FloatType;
import net.imglib2.util.Intervals;
import net.imglib2.view.IntervalView;
import net.imglib2.view.Views;

/**
 * A cell loader that fill {@link RandomAccessibleInterval} with data that is
 * generated by ImageJ slice filters.  Always goes through
 * {@link FloatProcessor}.  Is this necessary?
 *
 * @author Stephan Saalfeld
 * @param <T> type of input and output
 */
public class ImageJStackOp<T extends RealType<T> & NativeType<T>> implements Consumer<RandomAccessibleInterval<T>> {

	final RandomAccessible<T> input;
	final Consumer<FloatProcessor> sliceFilter;
	final double minIntensity, maxIntensity;
	final int padding;

	public ImageJStackOp(
			final RandomAccessible<T> input,
			final Consumer<FloatProcessor> sliceFilter,
			final int padding,
			final double minIntensity,
			final double maxIntensity) {

		this.input = input;
		this.sliceFilter = sliceFilter;
		this.minIntensity = minIntensity;
		this.maxIntensity = maxIntensity;
		this.padding = padding;
	}

	public ImageJStackOp(
			final RandomAccessible<T> input,
			final Consumer<FloatProcessor> sliceFilter,
			final int padding) {

		this(
				input,
				sliceFilter,
				padding,
				-Float.MAX_VALUE,
				Float.MAX_VALUE);
	}

	@SuppressWarnings("unchecked")
	@Override
	public void accept(final RandomAccessibleInterval<T> output) {

		final T type = net.imglib2.util.Util.getTypeFromInterval(output).createVariable();
		final int n = output.numDimensions();
		final long[] min = Intervals.minAsLongArray(output);
		final long[] max = Intervals.maxAsLongArray(output);

		min[0] -= padding;
		min[1] -= padding;
		max[0] += padding;
		max[1] += padding;

		final IntervalView<FloatType> inputInterval = Views.interval(
				Converters.convert(
						input,
						(a, b) -> {
							b.set(a.getRealFloat());
						},
						new FloatType()),
				min,
				max);

		RandomAccessibleInterval<FloatType> inputSlice = inputInterval;
		RandomAccessibleInterval<T> outputSlice = output;
		final long[] slicePosition = min.clone();

		for (int d = 2; d < n;) {

			/* slice */
			for (int i = n - 1; i >= 2; --i) {
				inputSlice = Views.hyperSlice(inputInterval, i, slicePosition[i]);
				outputSlice = Views.hyperSlice(output, i, slicePosition[i]);
			}

			/* make FloatProcessor copy */
			final FloatProcessor fp = Util.materialize(inputSlice);
			fp.setMinAndMax(minIntensity, maxIntensity);
			final ImagePlus imp = new ImagePlus("", fp);

			/* do the work */
			sliceFilter.accept(fp);

			/* copy convert back to output block */
			Util.copy(
					Views.translate(
							Converters.convert(
									(RandomAccessibleInterval<T>)ImagePlusImgs.from(imp),
									(a, b) -> {
										b.setReal(Math.min(maxIntensity, Math.max(minIntensity, a.getRealFloat())));
									},
									type),
							Arrays.copyOf(min, 2)),
					outputSlice);

			/* increase slicePositions */
			for (d = 2; d < n; ++d) {
				++slicePosition[d];
				if (slicePosition[d] <= max[d])
					break;
				else
					slicePosition[d] = min[d];
			}
		}
	}
}

