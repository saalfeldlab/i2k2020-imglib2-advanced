package org.janelia.saalfeldlab.i2k2020.ops;

import java.util.Arrays;
import java.util.function.BiConsumer;
import java.util.function.Consumer;

import org.janelia.saalfeldlab.i2k2020.util.Util;

import net.haesleinhuepf.clij.clearcl.ClearCLBuffer;
import net.haesleinhuepf.clij.converters.implementations.ClearCLBufferToRandomAccessibleIntervalConverter;
import net.haesleinhuepf.clij.converters.implementations.RandomAccessibleIntervalToClearCLBufferConverter;
import net.haesleinhuepf.clij2.CLIJ2;
import net.imglib2.RandomAccessible;
import net.imglib2.RandomAccessibleInterval;
import net.imglib2.type.NativeType;
import net.imglib2.type.numeric.RealType;
import net.imglib2.util.Intervals;
import net.imglib2.view.Views;

/**
 * A cell loader that fill {@link RandomAccessibleInterval} with data that is
 * generated by CLIJ2 filters.
 *
 * @author Stephan Saalfeld
 * @param <T> output type
 * @param <S> source type
 */
public class CLIJ2FilterOp<T extends RealType<T> & NativeType<T>, S extends RealType<S>> implements Consumer<RandomAccessibleInterval<T>> {

	protected final RandomAccessible<S> source;
	protected final long[] padding;
	protected final CLIJ2 clij2;
	protected BiConsumer<ClearCLBuffer, ClearCLBuffer> filter = (a, b) -> {};

	public CLIJ2 getClij2() { return clij2; }
	public void setFilter(final BiConsumer<ClearCLBuffer, ClearCLBuffer> filter) {

		this.filter = filter;
	}

	public CLIJ2FilterOp(
			final RandomAccessible<S> source,
			final String gpuId,
			final long... padding) {

		this.source = source;
		final int n = source.numDimensions();
		if (n == padding.length)
			this.padding = padding;
		else
			this.padding = Arrays.copyOf(padding, n);
		clij2 = CLIJ2.getInstance(gpuId);
	}

	public CLIJ2FilterOp(
			final RandomAccessible<S> source,
			final long... padding) {

		this(source, null, padding);
	}

	@SuppressWarnings("unchecked")
	@Override
	public void accept(final RandomAccessibleInterval<T> cell) {

		final RandomAccessibleIntervalToClearCLBufferConverter rai2cl = new RandomAccessibleIntervalToClearCLBufferConverter();
		rai2cl.setCLIJ(clij2.getCLIJ());

		final ClearCLBuffer input = rai2cl.convert(Views.interval(source, Intervals.expand(cell, padding)));
		final ClearCLBuffer output = clij2.create(input);

		filter.accept(input, output);

		final ClearCLBufferToRandomAccessibleIntervalConverter cl2rai = new ClearCLBufferToRandomAccessibleIntervalConverter();
		cl2rai.setCLIJ(clij2.getCLIJ());
		final RandomAccessibleInterval<T> result = cl2rai.convert(output);

		Util.copyReal(result, Views.translate(Views.zeroMin(cell), padding));

		input.close();
		output.close();
	}
}

